# Что является корректным поведением

В этом разделе я опишу корректное поведение по тестовым кейсам
указанным в задаче и укажу почему это поведение является корректным.

### Сервер должен корректно обрабатывать ситуацию, когда агент прекратил работать между сборками.
1. Когда процесс-агент прекратил свою работу, т.к. мы используем `http` процесс-сервер не узнает
о выключении процесса-агента и будет считать его запущенным.
2. Во время вызова метода `_recycle`
[simple-ci/server/modules/engine.js:196](../server/modules/engine.js)
попробует отправить данные выключенному процесс-агенту не получится и информация о мертвом
процесс-агенте очистится в методе `_onAgentDied` [simple-ci/server/modules/engine.js:272](../server/modules/engine.js)
3. В том же вызове `_recycle` процесс-сервер попробует найти другого процесс-агента,
чтобы отправить отправить данные для сборки.
4. Если у него не получилось это сделать, то все не выполненые запросы на сборку будут
хранится в переменных `._queue` и `._pendings` [simple-ci/server/modules/engine.js:32](../server/modules/engine.js).
До тех пор пока не вызовется новый `_recycle`, который может быть вызван при:
    1. Получении запроса на сборку.
    2. Получении данных о выполненной сборке
    3. При регистрации нового агента.

Такое поведение связано с тем, что именно сервер отвечает за хранение всех сборок.

### Сервер должен корректно обрабатывать ситуацию, когда агент прекратил работать в процессе выполнения сборки.
1. Когда агент прекратил работу сервер будет, считать, что агент выполняет сборку и будет хранить задачу
на сборку в переменной `._pendings`.
2. Но у сервера есть интервал в одну минуту, который проверяет в методе
`_recyclePendings`[simple-ci/server/modules/engine.js:143](../server/modules/engine.js)
существуют ли долго выполняющиеся (более 1 минуты) задачи на сборку.
3. Если такие задачи есть, то сервер отправит повторный запрос агенту, который выполняет эту задачу.
4. Если агент живой, то он примет эту задачу, но выполнять не будет, а если мертвый, то сервер
попытается отдать эту задачу другому агенту.


1. Если есть долго выполняющаяся задача на сборку,
но нет агента, который ее выполняет, то задача будет перемещена
в очередь задач на выполнение (переменная `._queue`)
2. Вызовется `_recycle`

Поведение корректно, потому что у нас нет события дисконнекта агента и интервал наиболее оптимальное
решение.

### Сервер должен корректно обрабатывать ситуацию, когда агенты не справляются с поступающими заявками.
**Ремарка**: Не совсем понял как выяснить справляется ли агент с поступающими заявками,
сделал так, чтобы агент отказывался выполнять более 10 заявок.

1. Во время `_recycle` сервер пытается отправить задачу на сборку.
2. Агент может отказаться принимать задачу.
3. Тогда сервер попытается отправить задачу другому агенту.
4. Если все агенты заняты и не могут принять задачу, то `_recycle` завершится
и задача будет находится в очереди, до  следующего `_recycle`, который может быть вызван при:
    1. Получении запроса на сборку.
    2. Получении данных о выполненной сборке
    3. При регистрации нового агента.


### Агент должен корректно обрабатывать ситуацию, когда при старте не смог соединиться с сервером.
1. Он должен выключиться с ошибкой, потому что не сможет выполнять задачи без сервера.
Ждать подключения сервера не имеет смысла, т.к. он может быть запущен по любому адресу.

### Агент должен корректно обрабатывать ситуацию, когда при отправке результатов сборки не смог соединиться с сервером.
**Ремарка:** Когда задавали вопросы к заданию, решили, что процесс-сервер должен хранить выполненые комманды
в памяти, а не в файловой системе.

Он должен выключиться с ошибкой, потому что:
1. Если упал сервер, то все текущие задачи на сборку не актуальны.
2. Хранить результаты сборки задача не агента, а сервера.
3. Ждать подключения сервера не имеет смысла, т.к. он может быть запущен по любому адресу.
